<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Help" xml:space="preserve">
    <value>
Copyright (c) 2011 Ivan Gavryliuk.

syntax: {0} &lt;command&gt; [&lt;options&gt;]

any options are optional and always have default values
to get extended help on a command type "{0} help &lt;command&gt;" i.e "{0} help pack"

Commands:
  pack - create package based on manifest definition
  publish - publish package to a repository(ies)
  template - create an empty (and invalid) manifest
  resolve - resolve dependencies and refresh project packages specifiend in the manifest
  search - search for packages in repositories
  info - prints out information about registered repositories
  update - checks for updates and if there is a new version performs the actual update</value>
  </data>
  <data name="Help_info" xml:space="preserve">
    <value>syntax: {0} info

Prints out information about registered repositories</value>
  </data>
  <data name="Help_pack" xml:space="preserve">
    <value>syntax: {0} pack [-m:&lt;manifest location&gt;] [-o:&lt;target folder&gt;] [-v:&lt;version override&gt;]

Creates a package based on the manifest file. Source files required for the package must exist.
  &lt;manifest location&gt; is a name or path to manifest file; by default manifest is taken from the current folder
  &lt;target folder&gt; specifies output folder for the compiled package; by default folder of manifest's location is used
  &lt;version override&gt; is used to override the version number inside the manifest; very useful in build scripts

examples:
  {0} pack
  {0} pack -m:library.pundit
  {0} pack -o:c:\packages\
  {0} pack -m:../pundit.xml -o:../ -v:3.0.1.401</value>
  </data>
  <data name="Help_publish" xml:space="preserve">
    <value>syntax: {0} publish [-p:&lt;package&gt;] [-r:&lt;repository name&gt;]

Publishes packages to repositories. By default all the packages in the current folders are published. Use optional parameters to override this behavior.
  &lt;package&gt; specificies a package to publish; by default all packages in the current folder are published
  &lt;repository name&gt; specifies repository to publish to; by default packages are published to repositories specified in the local configuration file; &lt;repository name&gt; is a "name" attribute of a repository from the local configuration file; for testing purposes publishing to local repository can be done specifyint "local" as the repository name

examples:
  {0} publish
  {0} publish -p:packed/*.pundit
  {0} publish -r:corporate</value>
  </data>
  <data name="Help_repo" xml:space="preserve">
    <value>syntax: {0} repo &lt;subcommand&gt;

Repository management functions. Subcommands supported:

  list - prints the list of registered repositories and some local statistics, has no extra parameters. Example:
  {0} repo list

  add - adds a new repository to local configuration. Requires repository tag, uri and refresh interval (in hours) to be passed. The following example adds repository named 'intranet' located at http://intranet/pundit/repository and pulling updates every 5 hours:
  {0} repo add intranet http://intranet/pundit/repository 5

  caps - updates existing repository capabilities.
  syntax: {0} caps &lt;caps&gt;

  caps supported:
    refresh - update the refresh interval (value in hours)
    enable - enables or disables repository
    publish - enables or disables publishing to this repository

  Following example enables publishing and changes refresh interval to 2 hours:
  {0} repo caps --refresh:2 --enable:true

  delete - deletes repository.
  syntax: {0} repo delete &lt;tag&gt;
  example: {0} repo delete corporate

  update - checks if repositories need to be updated and runs update process if required. The -f parameters forces update for all repositories even if time has not yet came.

  purgelocal - deletes local repository cache and compacts local database. Any binaries needed for the resolution process will be re-downloaded next time.</value>
  </data>
  <data name="Help_resolve" xml:space="preserve">
    <value>syntax: {0} resolve [-m:&lt;manifest location&gt;] [-d:&lt;depth&gt;] [-c:&lt;configuration name&gt;] [-f] [-p]

Resolves manifest version dependencies, checking for conflicts, downloading missing libraries and installing them into the solution.
  &lt;manifest location&gt; is a name or path to manifest file; by default manifest is taken from the current folder
  &lt;depth&gt; is a repository search depth; by default all the repositories are searched, however this can be overriden; set depth "local" to search only the local repository or to a number which specifies how many repositories specified in the local configuration file to search
  &lt;configuration name&gt; build configuration (debug or release); by default release is used; if a dependency doesn't include debug build release will be used
  -f parameter specifies that all dependencies must be deleted and reinstalled from scratch even if none changed since the last time
  -p parameter specifies that dependencies must be checked but no changes to the local repository should be made; use it to check for changes without updating to latest versions

examples:
  {0} resolve
  {0} resolve -p:Pundit.Extensions.xml
  {0} resolve -d:local
  {0} resolve -d:2
  {0} resolve -c:debug
  {0} resolve -f</value>
  </data>
  <data name="Help_search" xml:space="preserve">
    <value>syntax: {0} search &lt;-t:text&gt; [&lt;-d:depth&gt;] [&lt;-x&gt;]

  &lt;text&gt; is mandatory package name or name part (case insensitive). -t parameter name can be ommited so that the first nameless parameter will become a search expression
  &lt;depth&gt; is a repository search depth; by default all the repositories are searched, however this can be overriden; set depth "local" to search only the local repository or to a number which specifies how many repositories specified in the local configuration file to search
  &lt;x&gt; is an optional switch allowing to output the search result in XML format ready for copy-pasting into the manifest file

examples:
  {0} search -t:log4net
  {0} search log4net -x
  {0} search -t:log4net -d:local</value>
  </data>
  <data name="Help_template" xml:space="preserve">
    <value>syntax: {0} template

Has no extra parameters. Creates template manifest file with fake data.</value>
  </data>
  <data name="Help_update" xml:space="preserve">
    <value>syntax: {0} update</value>
  </data>
</root>
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Banner" xml:space="preserve">
    <value>pundit v{0} - http://pundit.codeplex.com</value>
  </data>
  <data name="Help" xml:space="preserve">
    <value>
Copyright (c) 2011 Ivan Gavryliuk.

syntax: {0} &lt;command&gt; [&lt;options&gt;]

any options are optional and always have default values
to get extended help on a command type "{0} help &lt;command&gt;" i.e "{0} help pack"

Commands:
  pack - create package based on manifest definition
  publish - publish package to a repository(ies)
  template - create an empty (and invalid) manifest
  resolve - resolve dependencies and refresh project packages specifiend in the manifest
  search - search for packages in repositories</value>
  </data>
  <data name="Help_pack" xml:space="preserve">
    <value>syntax: {0} pack [-m:&lt;manifest location&gt;] [-o:&lt;target folder&gt;] [-v:&lt;version override&gt;]

Creates a package based on the manifest file. Source files required for the package must exist.
  &lt;manifest location&gt; is a name or path to manifest file; by default manifest is taken from the current folder
  &lt;target folder&gt; specifies output folder for the compiled package; by default folder of manifest's location is used
  &lt;version override&gt; is used to override the version number inside the manifest; very useful in build scripts

examples:
  {0} pack
  {0} pack -m:library.pundit
  {0} pack -o:c:\packages\
  {0} pack -m:../pundit.xml -o:../ -v:3.0.1.401</value>
  </data>
  <data name="Help_publish" xml:space="preserve">
    <value>syntax: {0} publish [-p:&lt;package&gt;] [-r:&lt;repository name&gt;]

Publishes packages to repositories. By default all the packages in the current folders are published. Use optional parameters to override this behavior.
  &lt;package&gt; specificies a package to publish; by default all packages in the current folder are published
  &lt;repository name&gt; specifies repository to publish to; by default packages are published to repositories specified in the local configuration file; &lt;repository name&gt; is a "name" attribute of a repository from the local configuration file; for testing purposes publishing to local repository can be done specifyint "local" as the repository name

examples:
  {0} publish
  {0} publish -p:packed/*.pundit
  {0} publish -r:corporate</value>
  </data>
  <data name="Help_resolve" xml:space="preserve">
    <value>syntax: {0} resolve [-m:&lt;manifest location&gt;] [-d:&lt;depth&gt;] [-c:&lt;configuration name&gt;] [-f]

Resolves manifest version dependencies, checking for conflicts, downloading missing libraries and installing them into the solution.
  &lt;manifest location&gt; is a name or path to manifest file; by default manifest is taken from the current folder
  &lt;depth&gt; is a repository search depth; by default all the repositories are searched, however this can be overriden; set depth "local" to search only the local repository or to a number which specifies how many repositories specified in the local configuration file to search
  &lt;configuration name&gt; build configuration (debug or release); by default release is used; if a dependency doesn't include debug build release will be used
  -f parameter specifies that all dependencies must be deleted and reinstalled from scratch even if none changed since the last time

examples:
  {0} resolve
  {0} resolve -p:Pundit.Extensions.xml
  {0} resolve -d:local
  {0} resolve -d:2
  {0} resolve -c:debug
  {0} resolve -f</value>
  </data>
  <data name="Help_search" xml:space="preserve">
    <value>syntax: {0} search &lt;-t:text&gt; [&lt;-d:depth&gt;]

  &lt;text&gt; is mandatory package name or name part (case insensitive&gt;
  &lt;depth&gt; is a repository search depth; by default all the repositories are searched, however this can be overriden; set depth "local" to search only the local repository or to a number which specifies how many repositories specified in the local configuration file to search

examples:
  {0} search -t:log4net
  {0} search -t:log4net -d:local</value>
  </data>
  <data name="Help_template" xml:space="preserve">
    <value>syntax: {0} template

Has no extra parameters. Creates template manifest file with fake data.</value>
  </data>
</root>